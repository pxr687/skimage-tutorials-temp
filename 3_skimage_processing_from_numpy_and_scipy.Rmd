---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# (Sci-kit) Image processing via NumPy and SciPy

We saw on the [previous pages](0_images_as_numpy_arrays.Rmd) how images can be represented as NumPy arrays. This page will explore foundational image processing techniques, as operations on the values in a NumPy image array. First, we will explore how to acheive specific effects using NumPy and SciPy - and we will demonstrate what the operations are doing to an image at the level of the array pixels. Following that, we will show how more sophisticated extensions of these techniques can be implemented with Scikit-image, focusing on how it is often the same NumPy and Scipy operations that Sci-kit image is using "under the hood".

Remember that *image processing is when we do something which changes the numbers inside the array, and therefore change the corresponding visual image*? Well, in fact, all that fancy image processing software is doing is just changing the pixel values inside image arrays, in various ways. This is true for both image processing software with a graphical user interface, like [Adobe Photoshop](https://www.adobe.com/th_en/products/photoshop), as well as code-based image processing software like Scikit-image.

Let's again build a simple image array, and look at how we can use NumPy to achieve some pretty radical changes to the original image. We will then look at the specific purposes that such changes are used for, with more complex images.

First, we create our image array:

```{python}
import numpy as np
import matplotlib.pyplot as plt
import skimage as ski

# Import a custom function to give hints for some exercises.
from hints import hint_split_i, hint_cryptic_camera

# Set precision for float numbers
# %precision 2

# Set 'gray' as the default colormap
plt.rcParams['image.cmap'] = 'gray'

# A custom function for showing image attributes.
from show_attributes import show_attributes

# Create our image array.
i_img = np.array([[0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 1, 1, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0]],
                  dtype=float)

# Show the image array.
plt.imshow(i_img);
```

We have already encountered the use of `np.flip()` as a tool for rudimentary image manipulation. We use it to, well, flip an image array on its head:

```{python}
# Flip the array.
flipped_i = np.flip(i_img)

# Show the "raw" array pixel values.
print(flipped_i)

# Display the array with Matplotlib.
plt.imshow(flipped_i);
```

# Resizing an image

Now, *any operation that changes the numbers in the array* is a form of image manipulation. The term *image processing* generally means we are applying image manipulations *to achieve a specific purpose* - like improving image quality or clarity, for instance.

Let's say we want to *resize* our image array. Using NumPy, there are many ways to the same destination. Provided we want to *double* the size along a given dimension, we can achieve what we want using `np.repeat()`. 

```{python}
# Double the image, along the rows.
doubled_i_rows = np.repeat(i_img, 
                           repeats=2,
                           axis=0)

# Show the "raw" array pixel values.
print(doubled_i_rows)

# Display the array with Matplotlib.
plt.imshow(doubled_i_rows);
```

We can compare the attributes, including the `shape` of each array, using a custom function we defined in the first cell of this notebook:

```{python}
show_attributes(i_img)
```

```{python}
show_attributes(doubled_i_rows)
```

We can see that we have twice the number of rows in the `doubled_i_rows` image.

We can also double along the columns, by setting `axis = 1`:

```{python}
# Double along the columns.
doubled_i_cols = np.repeat(i_img, 
                           repeats=2,
                           axis=1)
# Show the result.
print(doubled_i_cols)
plt.imshow(doubled_i_cols);
```

```{python}
# Indeed, the columns have doubled.
show_attributes(doubled_i_cols)
```

By combining these operations, we can double along both the rows and the columns:

```{python}
# Double the whole image.
doubled_i =  np.repeat(i_img, 
                       repeats=2, 
                       axis=0)
doubled_i =  np.repeat(doubled_i, 
                       repeats=2,
                       axis=1)

# Show the result.
print(doubled_i)
plt.imshow(doubled_i);
```

```{python}
# The original image size was (15, 8).
show_attributes(doubled_i)
```

::: {exercise-start}
:label: i-!
:class: dropdown
:::

Your job now is to use only NumPy operations to create the following image array:

![](images/eye-!.png)

It should have the following attributes:

```
Type: <class 'numpy.ndarray'>
dtype: float64
Shape: (30, 8)
Max Pixel Value: 1.0
Min Pixel Value: 0.0
```

*Hint*: you may want to investigate NumPy functions for combining arrays together...

```{python}
# YOUR CODE HERE
i_exclam = ...
```

::: {exercise-end}
:::

::: {solution-start} i-!
:class: dropdown
:::

You can do this in one line of code using a combination of `np.concat()` which will "stick" arrays together (rather than `np.repeat()`-ing the values...). 

Combined with `np.flip()` we can produce the desired result in one line of code:

```{python}
# Combine the two `i_img` arrays, flip the second.
plt.imshow(np.concat([i_img, np.flip(i_img)]));
```

::: {solution-end}
:::


::: {exercise-start}
:label: split-i
:class: dropdown
:::

Here again is the `i_img` array, and a printout of its attributes:

```{python}
show_attributes(i_img)
plt.imshow(i_img);
```

Now, your task is to find a way, again using only NumPy, to alter the `i_img` array so it becomes this image:

![](images/split_i.png)

The image should have the following attributes:

```
Type: <class 'numpy.ndarray'>
dtype: float64
Shape: (15, 7)
Max Pixel Value: 1.0
Min Pixel Value: -1.0
```

*Note*: notice how we have lost a column, relative to the original `i_img` array...We also now have -1 values in the array, have a think about which colours in the displayed image you think that these negative values will correspond to.

*Hint:* run the function `hint_split_i()`, which was imported at the beginning of this notebook, to see a helpful hint.

```{python}
# YOUR CODE HERE
split_i = ...
```

::: {exercise-end}
:::

::: {solution-start} split-i
:class: dropdown
:::

The target image can be achieved using the `np.diff()` function, which will calculate the difference between adjacent values in an array.

By default `np.diff()` operates in steps of 1 across the rows:

```{python}
# Calculate the difference between values along the rows, in steps of 1.
split_i_solution = np.diff(i_img)

# Show the "raw" NumPy array.
print(split_i_solution)

# Display the image.
plt.imshow(split_i_solution);
```

Why is the background now grey? Well, remember that, for a monochrome image visualised with the `gray` colourmap, the most intense (highest value) pixels are white, and the least intense (lowest value) pixels are black, and intermediate values are a shade of grey?

Well, subtracting the values along the rows (the third value is subtracted from the fourth value etc.) entails the difference is being calculated as `1 - 0 = 1` for 1 values on the left hand side of the original image, and `0 - 1 = -1` for 1 values on the right hand side of the original image: 

```{python}
# Show before/after applying `np.diff()` to the image array.
print(f'Before:\n {i_img}')
print(f'After:\n {split_i_solution}')
```

So our highest values are now 1, our lowest values are -1, and our intermediate values are 0 (e.g. where the difference between elements was calculated from `1 - 1 = 0` or `0 - 0 = 0`). A range from -1 to 1 is still supported in `skimage` for the `float64` `dtype`.

White areas (pixel = 1) indicate a change between pixels in the horizontal direction (moving left-to-right) from black-to-white, in the original image. Black areas (pixel = -1) indicate a change in the horizontal direction from white-to-black. Grey areas indicate no change (pixel = 0).


::: {solution-end}
:::


## Resizing an image with `skimage`

The `ski.transform` module contains a function called `resize`. It is probably easy to guess what `ski.transform.resize()` does. It takes an input image and changes its size. Because all computer images are at least 2-D arrays, this involves changing the dimensionality of the image. Let's demonstrate this with the following image array:

```{python}
# Create an image array.
squares = np.array([[1, 0,], 
                    [0, 1,]], 
                   dtype=float)

# Show the array ("raw" output from NumPy)
print(squares)

# Show the array, visualised with Matplotlib
plt.matshow(squares);
```

What happens if we resize `squares` to (10, 10)? We will use the optional Boolean `preserve_range` argument which ensures the numbers in the output image stay within the range of those we give to the function:

```{python}
# Pass our `squares` array to the `ski.transform.resize()` function.
squares_ten_by_ten = ski.transform.resize(squares,
                                          output_shape=(10, 10),
                                          preserve_range=True)

# Show the resized array.
squares_ten_by_ten
```

```{python}
# Show the image attributes.
show_attributes(squares_ten_by_ten)
```

```{python}
# Display the image.
plt.imshow(squares_ten_by_ten);
```

Well, that is certainly more artistic than the original!

We now have many more `unique` values in the output array than there were in the input array (the input array contained only 0's and 1's), because `skimage` is interpolating for many new pixels. This means that it is estimating values for the new pixels which fall in between the array pixels from the original array image, based on the a weighted average of the values of the original pixels which they are nearest to:

```{python}
# Show the `unique` values.
np.unique(squares_ten_by_ten)
```

The array pixels highlighted in red are the original pixels from the `(2, 2)` original array:

![](images/resize_interpolation.png)

All the other pixels have been added by `skimage` during the `resize`-ing process. Pixels closer to the original pixels share closer intensity values to the original pixel (meaning they are more black or more white, depending on the original pixel). Images further from the original pixels become more grey.

We can control the type of interpolation that `skimage` uses by changing the (somewhat cryptically named) `order` argument. Setting this to 0 will activate [nearest neighbour interpolation](https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation):

```{python}
# Pass our `squares` array to the `ski.transform.resize()` function.
squares_ten_by_ten = ski.transform.resize(squares,
                                          output_shape=(10, 10),
                                          preserve_range=True,
                                          order=0) # Change the interpolation method.

# Show the resized array.
plt.imshow(squares_ten_by_ten);
```

This seems much closer to what we want when we `resize` the image. However, the results of image processing are highly context dependent, and there may be images for which the default interpolation setting works better...


# Rotation

Another common image manipulation we may want to do is to rotate an image. Should we only want to rotate by increments of 90 degrees, we can use the helpfully named `np.rot90()` function:

```{python}
# Rotate the image.
rotated_i = np.rot90(i_img)

# Show the result.
print(rotated_i)
plt.imshow(rotated_i);
```

We can control the number of rotations with the `k` argument:

```{python}
# Rotate the image, twice!
rotated_i_180 = np.rot90(i_img, 
                         k=2) # Two 90 degree rotations.

# Show the result.
print(rotated_i_180)
plt.imshow(rotated_i_180);
```

Again, with NumPy there are many routes to the same destination, and you can see that has achieved the same result as using `np.flip()` as we saw above. Rotating in increments of 90 degrees will not change the *size* (e.g. number of pixels) in the array, however it will change the integer index location of the pixel values:

```{python}
# Show the shape of the original image and both 90 degree rotated images.
plt.subplot(1, 3, 1)
plt.title(f"`.shape` = {i_img.shape}")
plt.imshow(i_img)
plt.subplot(1, 3, 2)
plt.title(f"`.shape` = {rotated_i.shape}")
plt.imshow(rotated_i)
plt.subplot(1, 3, 3)
plt.title(f"`.shape` = {rotated_i_180.shape}")
plt.imshow(rotated_i_180);
```

```{python}
# Original image and 90 degree rotations all have the same number of elements (15*8 = 120)
i_img.size == rotated_i.size == rotated_i_180.size
```

The cell below demonstrates `np.flip`-ping an image, as well as `np.rot`-ating an image by 180 degrees:

```{python}
# Load in `camera`
camera = ski.data.camera()

# Rotate, flip 'n' plot!
plt.figure(figsize=(14, 4))
plt.subplot(1, 3, 1)
plt.imshow(camera)
plt.title('Original')
plt.subplot(1, 3, 2)
plt.imshow(np.rot90(camera, k=2))
plt.title('np.rot90(k=2)')
plt.subplot(1, 3, 3)
plt.imshow(np.flip(camera))
plt.title('np.flip()');
```

To rotate an image by more flexible increments, we need to bring in SciPy, another foundational component library of Scikit-image. The SciPy function `ndimage.rotate()` offers more flexible rotation. However, rotating by other angles will alter both the `shape` and `size` of the output image:

```{python}
# Import SciPy using the conventional name (`sp`).
import scipy as sp

# Rotate the image by 193 degrees.
rotated_i_193 = sp.ndimage.rotate(i_img, 
                                  angle=193)

# Show the "raw" array.
print(rotated_i_193)

# Render the image graphically.
plt.imshow(rotated_i_193);
```

```{python}
# Show the attributes of the rotated image.
show_attributes(rotated_i_193)
```

The cell below will loop through some different rotation angles, the `shape` of each image is shown below each plot:

```{python}
# A for loop to show multiple rotations, and the effect on
# the dimensionality of the resultant image array.
plt.figure(figsize=(12, 4))
for i, i_2 in enumerate(np.arange(361, step=45)):
    plt.subplot(1, 9, i+1)
    current_rot = sp.ndimage.rotate(i_img, 
                                    angle=i_2)
    plt.imshow(current_rot)
    plt.title(f"{i_2}°")
    plt.xlabel(f"{current_rot.shape}")
    plt.xticks([])
    plt.yticks([])
```

By default, the `shape` is altered so that the original array is shown within the output array. SciPy uses interpolation to estimate the values of the pixels it adds, where the `shape` of the output image is larger than the `shape` of the input image.

We can disable this behaviour by settings `reshape=False`, however, then we risk "cutting" off aspects of what our original image depicts:

```{python}
# A for loop to show multiple rotations, and the effect on
# the dimensionality of the resultant image array., but this time
# we do not allow SciPy to reshape the output arrays.
plt.figure(figsize=(12, 4))
for i, i_2 in enumerate(np.arange(361, step=45)):
    plt.subplot(1, 9, i+1)
    current_rot = sp.ndimage.rotate(i_img, 
                                    angle=i_2,
                                    reshape=False) # Do not reshape the output images.
    plt.imshow(current_rot)
    plt.title(f"{i_2}°")
    plt.xlabel(f"{current_rot.shape}")
    plt.xticks([])
    plt.yticks([])
```

## Rotating an image with `skimage`

Let's now look now at how rotating image arrays is handled in `skimage`. Image rotation, which we saw above using `np.rot90` and `scipy.ndimage.rotate()` can be achieved using the straightforwardly named `ski.transform.rotate()`, and the syntax works identically to `scipy.ndimage.rotate()`. We're thirsty and caffeine-deprived, so let's get some `coffee`:

```{python}
# Import and show an image.
coffee = ski.data.coffee()
plt.imshow(coffee);
```

We can achieve easy and flexible rotation with `ski.transform.rotate()`:

```{python}
# Rotate the `coffee` image with `skimage`.
rotated_coffee = ski.transform.rotate(coffee, 
                                      angle=75,
                                      resize=True) # Ensure the original image fits in side the
                                                   # output image.

plt.imshow(rotated_coffee);
```

The cell below plots a variety of rotations, using `skimage.transform.rotate()` to perform each rotation:

```{python}
# Many rotations...
plt.figure(figsize=(16, 10))
for i, i_2 in enumerate(np.arange(361, step=45)):
    plt.subplot(3, 3, i+1)
    current_rot = ski.transform.rotate(coffee, 
                                    angle=i_2,
                                    resize=False) # Do not reshape the output images.
    plt.imshow(current_rot)
    plt.title(f"{i_2}°")
    plt.xticks([])
    plt.yticks([])
```

Specifically for 90 degree rotations, you might be tempted to use a NumPy shortcut, and use the `.T` (transpose) method. This however, will do something different to rotation. The cell below demonstrates the `.T` method, with the `camera` image:

```{python}
# Transpose `camera`.
camera_transposed = camera.T
show_attributes(camera_transposed)
plt.imshow(camera_transposed)
plt.title("camera.T");
```

We now show a 90 degree rotation, using `ski.transform.rotate()`

```{python}
# Rotate by 90 degrees.
plt.imshow(ski.transform.rotate(camera, 
                                angle=90))
plt.title('ski.transform.rotate()');
```

We can see that the cameraman is facing a different direction in each image (taking a photo of the bottom of the image for the `.T` method, and taking a photo of the top of the image for a 90 degree rotation via `skimage`). 

The difference here is that transposing an image switches the rows and columns, such that the first row becomes the first column etc. Conversely, `skimage.transform.rotate()` pivots the pixels around a central point. Essentially, transposing gives a *mirroring effect* which is different from a rotation.

Pay attention to the location of the spoon in the `coffee` image. First, we `ski.transform.rotate()` it by 90 degrees. Then, we `.transpose` it, switching the rows and columns. As `coffee` is a 3-D image, the `.T` method will produce an error, because the colour channels will be moved into the wrong dimension - to avoid this we use the `.transpose` method, to keep the colour channels in third dimension, whilst switching the rows and columns:

```{python}
# The `shape` of the original `coffee` image.
coffee.shape
```

```{python}
# Why we cannot use the `.T` method. We get an array which
# is the wrong `shape` for a colour image!
coffee.T.shape
```

```{python}
coffee_transposed = coffee.transpose((1, 0, 2)) # Move the columns into the rows, the rows into the columns, 
                                               # and leave the colour channels in the third dimension.
plt.imshow(coffee_transposed); 
 
# Show the attributes (not that the `shape` is still correct for a colour image).
show_attributes(coffee_transposed)
```

Compare this to a 90 degree rotation via `skimage`, pay attention to the spoon!

```{python}
# Show the difference between rotating and transposing.
plt.subplot(1, 2, 1)
plt.imshow(ski.transform.rotate(coffee, angle=90, resize=True))
plt.title("ski.transform.rotate()")
plt.axis('off')
plt.subplot(1, 2, 2)
plt.imshow(coffee_transposed)
plt.title(".transpose()")
plt.axis('off');
```

Unless you specifically want a mirroring transformation, then use `.rotate()`!


::: {exercise-start}
:label: look-at-me
:class: dropdown
:::

Your mission now is to transform `camera` into this image:

![](images/look_at_me.png)

Your final image should have the following attributes:

```
Type: <class 'numpy.ndarray'>
dtype: uint8
Shape: (512, 1024)
Max Pixel Value: 255
Min Pixel Value: 0
```

*Hint*: if you did not complete the earlier exerise involving combining to `i_img` arrays, then you may want to investigate NumPy functions for combining arrays together to complete the current exercise...

*Caution:* you may run into some errors/odd outcomes because of `dtype`s here...

```{python}
# YOUR CODE HERE
look_at_me = ...
```

::: {exercise-end}
:::

::: {solution-start} look-at-me
:class: dropdown
:::

Here we need a transpose operation, followed by a rotation, followed by a concatenation.

That is a mouthful, let's break it down. First we transpose the `camera` array, we can use `.T` here rather than `.transpose` as we are dealing with a 2-D greyscale image:

```{python}
# Transpose `camera`.
mirror_camera = camera.T
plt.imshow(mirror_camera);
```

Now the image is transposed, we have achieved our "mirror" effect. To get this mirrored cameraman to look the other guy in the eye, we now need to rotate the image 270 degrees, for which we use `ski.transform.rotate()`:

```{python}
# Rotate and show.
rotated_mirror_camera = ski.transform.rotate(mirror_camera,
                                             angle=270,
                                             resize=True) # Preserve the dimensions to match the original.
plt.imshow(rotated_mirror_camera);
```

Now, we must combine the images, using `np.concat()`, combining along the columns (`axis = 1`). First, however, we need to ensure the `dtype`s match! If we don't we get an unexpected result:

```{python}
# Combine the images, non-matching `dtype`s...
look_at_me = np.concat([camera, rotated_mirror_camera], axis=1)
plt.imshow(look_at_me);
```

Oops. This has occurred because `ski.transform.rotate()` has converted the image to the `float64` dtype, whereas the original is `uint8`:

```{python}
# The attributes of the original image (look at the `dtype`).
show_attributes(camera)
```

```{python}
# The attributes of the rotated mirror image (look at the `dtype`).
show_attributes(rotated_mirror_camera)
```

Using `ski.util.img_as_ubyte()` will ensure that the pixel values match, giving us our final, surreal result:

```{python}
# Ensure matching `dtype`s.
rotated_mirror_camera = ski.util.img_as_ubyte(rotated_mirror_camera)

# Combine the images and show the result.
look_at_me = np.concat([camera, rotated_mirror_camera], axis=1)
plt.imshow(look_at_me);
```

If in doubt, check the `dtype`!

::: {solution-end}
:::


::: {exercise-start}
:label: yellow-fellow
:class: dropdown
:::

For this exercise, you should load in the `cat` image from `ski.data`. Here is the original `cat` image:

![](images/cat.png)

The original image has the following attributes:

```
Type: <class 'numpy.ndarray'>
dtype: uint8
Shape: (300, 451, 3)
Max Pixel Value: 231
Min Pixel Value: 0
```

Now, using only `numpy` and `skimage`, try to recreate this target image:

![](images/poor_cat.png)

Your output image should have the following attributes:

```
Type: <class 'numpy.ndarray'>
dtype: float64
Shape: (30, 30, 3)
Max Pixel Value: 0.76
Min Pixel Value: 0.0
```

```{python}
# YOUR CODE HERE
```

::: {exercise-end}
:::

::: {solution-start} yellow-fellow
:class: dropdown
:::

The solution here again involves multiple steps. First we load in the `cat` image:

```{python}
# Load in and show the `cat` image.
cat_solution = ski.data.cat()
show_attributes(cat_solution)
plt.imshow(cat_solution);
```

Next, to replicate the yellow-y tone of the target image, we "switch off" the blue colour channel (because red + green = yellow):

```{python}
cat_solution[:, :, 2] = 0
plt.imshow(cat_solution);
```

The target image has the `.shape` (30, 30, 3); the original image has the `.shape` (300, 451, 3).

To get the correct output image size, we must *downscale* the image. To do this, we can use `ski.transform.resize()`:

```{python}
# Downscale the image.
cat_solution = ski.transform.resize(cat_solution,
                                    output_shape=(30, 30, 3))
# Show the result.
show_attributes(cat_solution)
plt.imshow(cat_solution);
```

Now, we can see that the target image requires a rotation, through good judgment, or just trial and error, we can work out that this needs to be 45 degrees. We can also see that the image of the downscaled cat does not "fit" inside the final image. As such, we need to rotate *without resizing* the image. By default, `resize=False` so we can leave it on the default setting:

```{python}
# Rotate and show the result.
cat_solution = ski.transform.rotate(cat_solution,
                                    angle=45)
show_attributes(cat_solution)
plt.imshow(cat_solution);
```

::: {solution-end}
:::

# Cropping

The process of "cropping" is the removal areas of pixels from an image.

Because our images are just NumPy arrays, cropping is just NumPy indexing (duh!). As such, we can crop images just with indexing operations, without using specific NumPy (or `skimage`) functions.

For instance, we can "shave" our `i_img` array in half, along the columns by slicing along the columns:

```{python}
# Cut in half.
half_i = i_img[:, 4:8]
print(half_i)
plt.imshow(half_i);
```

Likewise along the rows (albeit the number of rows is odd!):

```{python}
plt.imshow(i_img[0:8, :]);
```

::: {exercise-start}
:label: cropped-camera
:class: dropdown
:::

Using the `camera` image, the original of which is shown again below...

![](images/camera.png)

Crop `camera` down to this target image, using only NumPy indexing:

![](images/camera_cropped.png)

*Hint:* using `plt.grid()` might be of use here...

```{python}
# YOUR CODE HERE
camera_exercise = camera.copy()
plt.imshow(camera);
```

::: {exercise-end}
:::

::: {solution-start} cropped-camera
:class: dropdown
:::

This is a simple task once you know what indexes you need. Using `plt.grid()` can make this information easier to obtain:

```{python}
# Show `camera`, with a helpful grid.
plt.imshow(camera)
plt.grid();
```

The exact indices we used are here:

```{python}
# Solution.
plt.imshow(camera[130:160, 240:320]);
```

::: {solution-end}
:::


# Masks
In image processing, a mask is a matrix/array containing a collection of elements in a certain shape. A mask is "placed" on an image, and pixel values under the mask are all replaced with a specific value. Let's demonstrate with a real image:

```{python}
coffee_grey = ski.io.imread("images/coffee_grey.png", 
                        as_gray=True) # We could also use indexing/skimage.color to do this, 
                                      # by removing colour channels.
show_attributes(coffee_grey)
plt.imshow(coffee_grey);
```

First we, extract the `shape` of the image, and store each element as a separate variable. In this case, the image is 2-D (e.g. single-channel, monochrome) and so we extract the number of rows and the number of columns:

```{python}
# Unpack and store the number of rows and number of columns.
dim_1, dim_2 = coffee_grey.shape

# Show the values.
dim_1, dim_2
```

Then we can these elements (579 and 867) via `np.orgid()` to create one array with 579 rows, and 1 column, and another array with 1 row and 867 columns. These elements can be used to make a 2-D mask, in a specific shape:

```{python}
# Create a grid, based on the image `shape`.
X, Y = np.ogrid[0:dim_1, 0:dim_2]

# Show the `shape` of the X elements.
print(X.shape)

# Show the first 10 elements of X.
X[:10, :]
```

```{python}
# Show the `shape` of the Y elements.
print(Y.shape)

# Show Y
Y
```

We can then use a geometric formula to generate a 2-D grid of a specific shape, as in the cell below:

```{python}
# Create a circulat mask.
mask = (X - dim_1/ 2) ** 2 + (Y - dim_2 / 2) ** 2 > dim_1 * dim_2 / 4
show_attributes(mask)
plt.imshow(mask);
```

Once we have our mask - which is just a Boolean array - it is just a matter of Boolean indexing to use it set all the pixel values underneath it to be equal to the same value:

```{python}
# Apply the mask.
coffee_grey_masked = coffee_grey.copy()
coffee_grey_masked[mask] = 0

plt.matshow(coffee_grey_masked);
```

::: {exercise-start}
:label: masked-man
:class: dropdown
:::


Use a mask to transform `camera` into the following image:
    
![](images/masked_camera.png)

This is easier than you think...try running the function `hint_cryptic_camera()` for a hint if you get stuck...


::: {exercise-end}
:::

::: {solution-start} masked-man
:class: dropdown
:::

The circular mask we used above was generated via the following:

`mask = (X - dim_1/ 2) ** 2 + (Y - dim_2 / 2) ** 2 > dim_1 * dim_2 / 4`

To obtain the mask you need for this exercise, we simply change the square exponents (`**2`) to cubes (`**3`):

```{python}
# Solution pt 1.
dim_1, dim_2 = camera.shape
X, Y = np.ogrid[0:dim_1, 0:dim_2]
mask_solution = (X - dim_1/ 2) ** 3 + (Y - dim_2 / 2) ** 3 > dim_1 * dim_2 / 4
plt.imshow(mask_solution);
```

```{python}
# Solution pt 2.
camera_masked_solution = camera.copy()
camera_masked_solution[mask_solution] = 1
plt.imshow(camera_masked_solution);
```

::: {solution-end}
:::


# Inverting image colours

We saw *colour inversion* on an [earlier page](0_images_as_numpy_arrays.Rmd). This is where all the pixel values in an image are, shockingly, inverted: high numbers become low numbers and vice versa:

For a binary image, this involves swapping 1s and 0s...

```{python}
# Original image
print(i_img)
plt.imshow(i_img);
```

...which can be accomplished with some simple numeric operations:

```{python}
inverted_i = (i_img * -1) + 1
print(inverted_i)
plt.imshow(inverted_i);
```

What about a colour image? 

```{python}
# Read in a colour image.
colourwheel = ski.io.imread("images/colourwheel.png")
show_attributes(colourwheel)
plt.imshow(colourwheel);
```

The numerical trick that we used with the binay image will not work for a colour image like this, because the pixel values range from 0 to 255. -255 is not allowed within the acceptable range for `uint8` image data and will produce an error!

```{python tags=c("raises-exception")}
# Shortcut will not work for colour images
plt.imshow(colourwheel * -1)
```

But remember that inversion means we, well, "invert" the pixel values. Because the maximum value is now 255, we can subtract each array pixel value in each colour channel from 255 to "reverse" the values:

```{python}
# Invert the colour image, manually.
inverted_colourwheel = colourwheel.copy()
for i in np.arange(3):
    inverted_colourwheel[:, :, i] = 255 - inverted_colourwheel[:, :, i] 
    
plt.imshow(inverted_colourwheel);
```

## Inverting colours with `skimage`

`ski.util.invert()` handles colour inversion, we simply pass it a colour NumPy image array and voilà!:

```{python}
# Invert the colour image, with `skimage`.
invert_colourwheel_with_skimage = ski.util.invert(colourwheel)
plt.imshow(invert_colourwheel_with_skimage);
```

::: {exercise-start}
:label: inv-brick
:class: dropdown
:::

Now over to you. Your task here is to load the `brick` image from `ski.data.image`.

You should then invert every 2nd element on even numbered rows...

So on *even* numbered rows (row 0, 2, 4, 6, etc.), if you went through the elements in pairs along the row, the *second* element in each pair should be inverted, vs the original image.

The original `brick` image looks like this:

![](images/bricks.png)

The original image has the following attributes:

```
Type: <class 'numpy.ndarray'>
dtype: uint8
Shape: (512, 512)
Max Pixel Value: 207
Min Pixel Value: 63 
```

Your final image should look like this:

![](images/inverted_bricks.png)

Your new image should have the following attributes:

```
Type: <class 'numpy.ndarray'>
dtype: uint8
Shape: (512, 512)
Max Pixel Value: 207
Min Pixel Value: 48 
```

Use only NumPy indexing and Scikit-image functions to do this...

*Hint:* remember that smaller NumPy arrays indexed out of larger NumPy arrays are still NumPy arrays, and so can be passed as arguments to most `skimage` functions.

```{python}
# YOUR CODE HERE
```

::: {exercise-end}
:::

::: {solution-start} inv-brick
:class: dropdown
:::


The solution here is just to use slicing to select the elements we need, and `ski.util.invert()` just these elements, using array indexing.

To get every 2nd element on even numbered rows, we can use `brick[0::2, 1::2]`.

This is easier to appreciate in a smaller array:

```{python}
small_arr = np.zeros((8, 8))
small_arr
```

```{python}
# Get every second element, on even numbered rows.
small_arr[0::2, 1::2] = 1
small_arr
```

```{python}
# Show the small array (0 elements are now grey).
plt.imshow(small_arr);
```

We can invert just the pixel values at these locations, by passing the slices to `ski.util.invert()`:

```{python}
# Solution.
brick_solution = ski.data.brick()

brick_solution[1::2, ::2] = ski.util.invert(brick_solution[0::2, 1::2])

show_attributes(brick_solution)
plt.imshow(brick_solution);
```

::: {solution-end}
:::

::: {exercise-start}
:label: inverted-purple
:class: dropdown
:::

Again using the `cat` image, try to recreate the following, using only `numpy` and `skimage`:

![](images/purple_inverted_cat.png)

```{python}
# YOUR CODE HERE
```

::: {exercise-end}
:::

::: {solution-start} inverted-purple
:class: dropdown
:::

The target image *cannot* be created using just `ski.util.invert()` on the whole `cat` image array:

```{python}
cat_solution_2 = ski.data.cat()
plt.imshow(ski.util.invert(cat_solution_2));
```

This looks cool - if anything *cooler* than the target image - but it is not what we want.

To recreate the target image, who must "switch" off the green colour channel *before* we invert the colours:

```{python}
cat_purple = cat_solution_2.copy()
cat_purple[:, :, 1] = 0
plt.imshow(cat_purple);
```

Now, when we invert the purple `cat` image, we get the target image:

```{python}
# Solution.
plt.imshow(ski.util.invert(cat_purple));
```

::: {solution-end}
:::

# Greyscale to binary conversion

Greyscale to binary conversion can be acheived using comparison operators (`<`, `>`, `<=`, `>=`, `==`). The resulting Boolean array will always be binary.

Let's demonstrate with a greyscale image:

```{python}
# Create a greyscale image.
np.random.seed(10)
random_check = np.array([[1, 0, 1, 0], 
                         [0, 1, 0, 1],
                         [1, 0, 1, 0],
                         [0, 1, 0, 1]], dtype=int)
random_check[random_check == 1] = np.random.randint(low=3,
                                                    high=11,
                                                    size=np.sum(random_check == 1))
plt.matshow(random_check);
```

```{python}
# Convert to a binary image:
binary_check = random_check > np.median(random_check)
print(binary_check)
plt.matshow(binary_check);
```

We can also easily acheive this conversion in `skimage` - see the [filtering page](5_filters_2) for more detail. For now, we can use the `ski.filters.threshold_minimum()` function. This supplies us a recommended threshold value to attempt to divide the array pixels into two classes e.g. two classes where the pixels in each class are maximally different from pixels in the other class:

```{python}
# Get a recommended threshold from `skimage`.
threshold = ski.filters.threshold_minimum(random_check)
threshold
```

We can then use this threshold to create a binary array, successfully binarizing our greyscale image:

```{python}
# Binarize the array, based on the threshold.
binary_check_from_ski = random_check > threshold
show_attributes(binary_check_from_ski)
plt.matshow(binary_check_from_ski);
```

# Colour to greyscale conversion

To downgrade a colour image to greyscale we can use a brute force method of taking the mean of the three colour channels, to produce a 2-D monochrome image array:

```{python}
grey_wheel = np.mean(colourwheel, 
                     axis=2)

plt.imshow(grey_wheel);
```

A better option here, that we encountered on the [previous page](2_skimage_intro), is to use the *luminance formula*:

$$
Y = 0.2126R + 0.7152G + 0.0722B
$$

This "collapses" a 3-D colour image into a 2-D greyscale image via a weighted sum of the channels.

::: {exercise-start}
:label: grey-wheel
:class: dropdown
:::

Here is the original `colourhweel` image:

![](images/colourwheel.png)

It has the following attributes:

```
Type: <class 'numpy.ndarray'>
dtype: uint8
Shape: (370, 371, 3)
Max Pixel Value: 255
Min Pixel Value: 0
```

Using the luminance formula, and any other required `numpy`, `scipy` or `skimage` operations, recreate the target image below, starting from the `colourwheel` array:

![](images/grey_wheel.png)

Your final image should have the following attributes:

```
Type: <class 'numpy.ndarray'>
dtype: uint8
Shape: (370, 371)
Max Pixel Value: 255
Min Pixel Value: 0
```

Try to use `np.dot()` rather than slicing, when you complete this exercise.

*Hint*: you may need to rescale the intensity values to match the target image attributes. You may recall there is a `skimage` function which can help you do this...

```{python}
# YOUR CODE HERE
```

::: {exercise-end}
:::

::: {solution-start} grey-wheel
:class: dropdown
:::

The solution here requires some close attention to `dtype`. To apply the luminance formula using `np.dot()` is pretty straightforward:

```{python}
# Solution pt 1.

# Luminance forumula coefficients
weights = np.array([0.2126, 0.7152, 0.0722])

# Run the numbers...
grey_wheel = np.dot(colourwheel, weights)

# Show the result.
show_attributes(grey_wheel)
plt.imshow(grey_wheel);
```

But this gives us min/max pixel intensity values which are illegal for the `float64` dtype, and will generate an error when we try to convert to `uint8` to match the target image:

```{python tags=c("raises-exception")}
# Ouch!
ski.util.img_as_ubyte(grey_wheel)
```

The `ski.exposure.rescale_intensity()` function can save us again here. First, we make the values legal for a `float64` image (`np.dot()` left us with float values, as the weights in the luminance formula are decimal numbers):

```{python}
# Rescale the pixel intensity values into a legal range, for the current `dtype`.
grey_wheel = ski.exposure.rescale_intensity(grey_wheel,
                              out_range=(0, 1))

show_attributes(grey_wheel)
```

Now, we can painlessly convert to `uint8`. Finally, to match the target image, we must `ski.transform.invert()` our depressingly dreary colourwheel:

```{python}
# Convert to `uint8` `dtype`.
grey_wheel = ski.util.img_as_ubyte(grey_wheel)

# Invert the colour and show the result.
grey_wheel =  ski.util.invert(grey_wheel)
show_attributes(grey_wheel)
plt.imshow(grey_wheel);
```

::: {solution-end}
:::


## Colour to greyscale conversion with `skimage`

As always, the `ski.color` module has us covered here with the `rgb2gray()` function. We simply pass it the colour array that we want to convert to greyscale, without the need for the luminance formula:

```{python}
# Convert colour to greyscale.
grey_colourwheel_from_ski = ski.color.rgb2gray(colourwheel)
show_attributes(grey_colourwheel_from_ski)
plt.imshow(grey_colourwheel_from_ski);
```

# Summary

This page has shown how to implement some fundamental image processing operations with NumPy, SciPy and Scikit-image. The next page will delve into [image filtering](5_filters_2).


# References

Reference: https://www.kdnuggets.com/numpy-for-image-processing

Reference: skimage tutorials (check versions), scipy lecture notes

Adapted from: https://lectures.scientific-python.org/advanced/image_processing

Adapted from: https://lectures.scientific-python.org/packages/scikit-image/index.html
