---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.17.3
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Morphology

[Morphology](https://en.wikipedia.org/wiki/Mathematical_morphology) is the
mathematical study of shapes and has numerous applications in image processing.
As such, Scikit-image has a dedicated module (`ski.morphology`) for associated
functions.

We have already encountered footprints and kernels
on [earlier](4_threshold_filters) [pages](5_mean_filter). A footprint is a grid
of a certain shape - you can think of it as a "template" â€” which is used to
define the "neighborhood" of pixels which an image processing operation
affects.  As you remember, a *kernel* is a footprint containing *weights*.  We
might consider kernels as specialized footprints.

::: {note}

**Footprints and structural elements**

You will see other tutorials refer to *footprints* as [structuring
elements](https://en.wikipedia.org/wiki/Structuring_element) or *structural
elements*.  We stick to "footprint" here for compatibility with the
Scikit-image terminology, but a footprint is the same a structuring/structural
element.

:::

A (3, 3) footprint can be applied as a square which affects 9 pixels - we might
alter the image by centering this footprint over every pixel, and replacing
each pixel with the mean of the other pixels in its "neighborhood", for
instance:

![](images/footprint_general.png)

You will also recall that we need a strategy for pixels at the edge of the
image, where we center the footprint on a pixel where part of the footprint
"falls off" the edge of the image:

![](images/footprint_hit_the_edge.png)

Options here including "padding" the empty footprint locations with a repeated
value (like 0), or just duplicating the existing pixels at the edge of the
image.

We have seen footprints and kernels applied during filtering operations,
courtesy of the `ski.filters` module. Morphological operations also make use of
footprints. As you remember, footprints (but not kernels) are binary (contain
only True / False or 0 / 1).

Morphological operations differ from the filtering operations we have seen
previously because they are specifically related to the shape (...or, well,
[*morphology*](https://www.cs.auckland.ac.nz/courses/compsci773s1c/lectures/ImageProcessing-html/topic4.htm))
of features within the image. This contrasts with operations like [mean
filtering](5_mean_filter) which "spread" pixel values around within
a neighborhood, rather than identifying and altering features with a specific
shape/morphology.

## Footprints

Because morphological operations are part of image processing, they involve the
modification of array pixel values. In morphological operations, the footprint
guides changes to pixel values *depending upon the match between the shape of
the footprint and the shape of the pixels in the "neighborhood" of the
footprint*.

The footprint, typically, is centered once on every pixel in an image, and this
central pixel is modified (or not) depending upon the match between the shape
of the footprint and the shape described by the pixel values in that
neighborhood.

Let's make ourselves a simple binary image, so we can see the effect of the
foundational morphological operations more clearly:

```{python}
import skimage as ski
import numpy as np
import matplotlib.pyplot as plt

# A custom function for displaying image attributes.
from skitut import show_attributes

# A custom function for comparison plots.
def show_both(original,
              altered,
              alteration='',
              figsize=(14, 14)):
    plt.figure(figsize=figsize)
    plt.subplot(1, 2, 1)
    plt.title('Original')
    plt.imshow(original)
    plt.subplot(1, 2, 2)
    plt.title(alteration)
    plt.imshow(altered)
    plt.show()

# Set 'gray' as the default colormap
plt.rcParams['image.cmap'] = 'gray'

# Make a binary square.
square = np.array([[0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 1, 1, 1, 0, 0],
                   [0, 0, 1, 1, 1, 0, 0],
                   [0, 0, 1, 1, 1, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0]], dtype=np.uint8)
plt.imshow(square);
```

Let's get fancy and ostentatious now, and invest in some diamonds, by which we
mean, let's use `ski.morphology.diamond()` to construct a footprint:

```{python}
# Create a `diamond` footprint.
# Changing `radius` will change the size of the diamond.
diamond = ski.morphology.diamond(radius=1)
diamond
```

```{python}
plt.matshow(diamond);
```

Using `ski.morphology.diamond(radius=1)` gives us a diamond shaped footprint of
`shape` (3, 3). We'd call it a "cross" but "diamond" is the canonical term...
Be assured that it will look more diamond-like (diamond-y?) when set to
a bigger `radius`...:

```{python}
diamond.shape
```

## Erosion

The fundamental operations of morphological image processing are [erosion](https://en.wikipedia.org/wiki/Erosion_(morphology)) and
[dilation](https://en.wikipedia.org/wiki/Dilation_(morphology)).  We will
consider erosion first.

Much like when bad behaviour spreads through a social group, erosion will, for
every pixel in the image:

1. Place the footprint over the pixel and
1. determine of the image intensity values under the footprint *match* the
   footprint shape (we will explain this soon), and then:
1. If the footprint matches, leave the pixel value unchanged in the output
   image.
1. If the footprint does not match, set the output pixel value to be the lowest
   image intensity value within the footprint.

As mentioned above, a full morphological operation involves centering the
footprint on *every pixel in the image*, so every pixel gets assessed for
alteration with reference to the other pixels in its neighborhood.

We can erode our binary square using `ski.morphology.erosion()`, we use the
`footprint` argument to specify our footprint:

```{python}
# Erode our image.
eroded_square = ski.morphology.erosion(square,
                                       footprint=diamond)
# Show the result.
eroded_square
```

```{python tags=c("hide-input")}
plt.imshow(eroded_square);
```

What has happened here? We can think of our `diamond` footprint as being a bit
like a weird [crosshair/reticle](https://en.wikipedia.org/wiki/Reticle) of
a gun. In a morphological operation, we "target" the crosshair on a given array
pixel. Because we are eroding, the central pixel will be *lowered to the value
of the lowest pixel in its neighborhood* if the pixels in the neighborhood do
not "match" the shape of the footprint. This is illustrated below.

Now, because our `square` array contains only 1s and 0s, central pixels "match"
the footprint if the pixels under the footprint are 1 where the values in the
footprint are 1. The image below shows the `diamond` footprint being applied to
three different central pixels. "Matches" between the footprint and the array
pixels are depicted with a green tick; "clashes" between the footprint and the
array pixels are depicted with a red X. "Clashes" occur where the footprint
value is 1 and the array pixel value is 0.

If a "clash" occurs, then the central pixel gets lowered to the lowest value
under the footprint (0). (We call this, loosely, the central pixel "dying").

If there is a full "match" between the neighborhood values and the footprint,
then the central pixel is left altered (we say that it "survives"):

![](images/hit_n_miss_with_text.png)


Let's repeat this erosion process with two `square` arrays `concatenate`d
together.

What do you think will happen when we erode them using the `diamond` footprint?
Try to predict before you check:

```{python}
# `concatenate` two `square` arrays.
two_squares = np.concatenate([square, square], axis=1)
plt.imshow(two_squares);
```

```{python}
# Perform the erosion.
eroded_two_squares = ski.morphology.erosion(two_squares, diamond)
eroded_two_squares
```

```{python}
# Plot the result of the erosion.
plt.imshow(eroded_two_squares);
```

What happened here? Well, again a "match" only occurs for two pixels in the
image, the pixels at the center of each white square. This illustration below
shows what happened:

![](images/hit_n_miss_with_text_2.png)


All other "neighborhoods" did not match the footprint, and so the values in the
neighborhood were lowered to 0, 0 being the lowest value in each neighborhood.
This has the effect, if a non-matching pixel has the value of 1, of setting it
to 0. If a non-matching pixel has a value of 0, it also gets set to 0, but it
was already 0, so there is no appreciable change.

Let's alter our image array slightly, to see how this affects the erosion operation with our `diamond` footprint. We will place a black array pixel inside the right-hand white square:

```{python}
# A modified array.
square_the_circle = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                               [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0],
                               [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0],
                               [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
                               dtype="uint8")

plt.imshow(square_the_circle);
```

Before looking at the output of the cell below, try to think carefully about how you think this will affect the erosion operation, using the (3, 3) `diamond` footprint. Picture what will happen on the black pixel in the center of the right-hand square.

Scroll down to the output of the cell below to see if your prediction was correct:

```{python}
eroded_square_the_circle = ski.morphology.erosion(square_the_circle, diamond)

plt.imshow(eroded_square_the_circle);
```

Ok, so now the whole right-hand square got taken out. Brutal.

Why did this happen? The cell below illustrates, again using green ticks for "matches" between the footprint and the pixel "neighborhood", and red X's for "clashes" between the footprint and the pixel "neighborhood".

Remember that a "clash" means the central pixel "dies"; a "match" means the central pixel "survives":

![](images/hit_n_miss_with_text_3.png)


## Dilation

The other foundational operation in morphological image processing is
*dilation*. Dilation works the same as erosion in terms of centering
a footprint on each pixel and looking for "matches" or "clashes". However, it
does exactly the opposite thing for pixels where it finds a "clash". Where, in
the event of a "clash", erosion *lowers* central pixel values down to the
neighborhood minimum, dilation instead *raises* central pixel to the value of
the neighborhood maximum.

Let's dilate the `square` array:

```{python}
# Show the `square` array.
square
```

```{python}
plt.imshow(square);
```

Now, we use `ski.morphology.dilation()` to dilate the image, again using
`diamond` as our footprint:

```{python}
# Perform the dilaton.
dilated_square = ski.morphology.dilation(square,
                                         footprint=diamond)
dilated_square
```

```{python}
plt.imshow(dilated_square);
```

Ok, so now some of the "clashes" have resulted in *more* white pixels in the
image. The illustration below shows this for three pixels, two "clashes" and
the one "match":

![](images/hit_n_miss_dilation.png)


What do you think will happen if we dilate the `square_the_circle` array image
shown below, using the `diamond` footprint?

Try to predict before checking:

```{python}
# Show the array.
square_the_circle
```

```{python}
plt.imshow(square_the_circle);
```

Let's see how good your prediction was:

```{python}
# Dilate the `square_the_circle` array, and show the result.
dilated_square_the_circle = ski.morphology.dilation(square_the_circle,
                                                    footprint=diamond)
plt.imshow(dilated_square_the_circle);
```

Why did this happen? The image below explains:


![](images/hit_n_miss_with_text_3_dilation.png)

For erosion, all of the "clashing" pixels in the right-hand square get
*lowered* to their neighborhood minimum, in this case 0, and so they "die" and
fade into the black background.

For dilation, clashing central pixels get *raised* to the neighborhood maximum,
which in this case is 1.

So, [remember](https://scikit-image.org/docs/0.25.x/auto_examples/applications/plot_morphology.html):

*Erosion enlarges dark regions and shrinks bright regions.*

*Dilation enlarges bright regions and shrinks dark regions.*


## Morphology using more complex images

Let's apply some of this to more complex images. Fittingly, we will use
a terrifying picture of a [Xenomorph](https://en.wikipedia.org/wiki/Xenomorph),
which at the time of writing Wikipedia defines as "a fictional endoparasitoid
extraterrestrial species that serves as the main antagonist of the Alien and
Alien vs. Predator franchises". Yikes.

```{python}
# Photo by Stockcake
# - https://stockcake.com/i/alien-head-close-up_1354662_1093149
xenomorph = ski.io.imread("images/xenomorph.jpg", as_gray=True)
# Convert to binary.
xenomorph = ski.util.img_as_bool(xenomorph).astype(int)

# Show the "raw" array.
xenomorph
```

```{python}
plt.imshow(xenomorph);
```

```{python}
# Show the attributes of `xenomorph`.
show_attributes(xenomorph)
```

Scary, especially as a binary image, but not quite as scary as the `smiley` image we [made](0_images_as_numpy_arrays) that still haunts our dreams.

True to form, eroding this image using the `diamond` footprint increases the
size of dark regions:

```{python}
# Erode the xenomorph.
xeno_binary_ero_rad_1_diamond = ski.morphology.erosion(xenomorph,
                                                       footprint=diamond)

# Show the result.
show_both(xenomorph, xeno_binary_ero_rad_1_diamond, "Eroded");
```

Whilst dilation increases the size of bright regions (creating a truly, truly
terrifying image):

```{python}
# Dilate the xenomorph.
xeno_binary_dilate_rad_1_diamond = ski.morphology.dilation(xenomorph,
                                                           footprint=diamond)

# Show the result.
show_both(xenomorph, xeno_binary_dilate_rad_1_diamond, "Dilated");
```

We can alter the size of the footprint to change the nature of the effect. The
exact change will be heavily dependent on the image array we are processing.
Here we create a diamond with `radius = 6`:

```{python}
# Create and show a larger diamond footprint.
diamond_6 = ski.morphology.diamond(radius=6)
diamond_6
```

```{python}
plt.imshow(diamond_6);
```

Applied to the `xenomorph` image in an erosion operation, this has some radical
results:

```{python}
xeno_binary_ero_rad_6_diamond = ski.morphology.erosion(xenomorph,
                                                       footprint=diamond_6)
show_both(xenomorph,
          xeno_binary_ero_rad_6_diamond,
          "Eroded \n(13, 13) Diamond SE");
```

There are fewer "matches" between the large footprint and pixel neighborhoods
in the image - this leaves less central pixels unchanged, than for a smaller
footprint of the same shape. Because in erosion we are *lowering* central pixel
values in the event of a "clash", the darker regions have expanded
substantially more than when we used a smaller `diamond`, which gave more
"matches".

Dilation, again has the opposite effect of increasing brighter regions, in the
event of "clashes":

```{python}
# Dilate the xenomorph with the `radius = 6` diamond.
xeno_binary_dilate_rad_6_diamond = ski.morphology.dilation(xenomorph,
                                                           footprint=diamond_6)
show_both(xenomorph,
          xeno_binary_dilate_rad_6_diamond,
          "Dilated \n(13, 13) Diamond SE");
```

We can also change the shape of the footprint - here we create a rectangle
(well, a square) of `shape` (3, 3):

```{python}
# A square footprint.
square_SE = ski.morphology.footprint_rectangle((3, 3))
square_SE
```

This new footprint is the same `shape` as the kernels we used on the [filtering
page](5_mean_filter). Below we use it to erode the xenomorph image:

```{python}
# Erode the xenomorph (with the square footprint).
xeno_binary_ero_square = ski.morphology.erosion(xenomorph,
                                                footprint=square_SE)
show_both(xenomorph,
          xeno_binary_ero_square,
          "Eroded \n(3,3) Square SE");
```

Dilation with this new footprint once more enlarges brighter regions, again
with horrific results:

```{python}
# Dilate the xenomorph, with the new footprint.
xeno_binary_dilate_square = ski.morphology.dilation(xenomorph,
                                                    footprint=square_SE)
show_both(xenomorph, xeno_binary_dilate_square, "Dilated \n(3,3) Square SE");
```

Changing the shape or size of the footprint will change the number of
"matches", and therefore the degree and location of changes to the bright/dark
regions, for both erosion and dilation. We are essentially looking for features
of a certain shape (the shape of our footprint) in the image, and then
dilating/eroding on the basis of the number of matches/clashes.

::: {exercise-start}
:label: block-xeno
:class: dropdown
:::

Try to recreate the following image by processing `xenomorph`, using only
`skimage` morphological operations, as well as operations from the other
tutorials, from `numpy`, `scipy` and `skimage`:

![](images/xeno_ex_1.png)

Look at the shape, the *morphology* of the features in the image - what shape
and size footprint do you think you need? Do you think you need dilation or
erosion?

For comparison, here is the original binarized image:

```{python}
plt.imshow(xenomorph);
```

```{python}
# YOUR CODE HERE
img = ...
```

::: {exercise-end}
:::

::: {solution-start} block-xeno
:class: dropdown
:::

We promised earlier that the `diamond` footprint would get more diamond-like
when it is larger. To complete this exercise, you need `big_diamond` with
`radius = 30`:

```{python}
# Expensive!
big_diamond = ski.morphology.diamond(radius=30)
plt.imshow(big_diamond);
```

Dilating with this `big_diamond` will give you the right outline, but the wrong colors:

```{python}
# Solution, part 1:
xeno_big_diamond = ski.morphology.dilation(xenomorph,
                                           footprint=big_diamond)
plt.imshow(xeno_big_diamond);
```

To get the target image, we need to `invert` the colors:

```{python}
# Solution, part 2:
inverted_xeno_big_diamond = ski.util.invert(xeno_big_diamond)
plt.imshow(inverted_xeno_big_diamond);
```

```{python tags=c("remove-cell")}
# This is not part of the solution, but here we save the resulting solution
# image to display in the exercise introduction above.
plt.imshow(inverted_xeno_big_diamond)
plt.savefig('images/xeno_ex_1.png')
```

::: {solution-end}
:::


## Skeletonizing an image

In keeping with the horror theme of the `xenomorph` image, and the legacy of
the [`smiley`](0_images_as_numpy_arrays) array, let's look at the
`ski.morpholoy.skeletonize()` function.

This takes a binary image and finds its "skeleton" - e.g. the centerline of shapes in the image, and marks it out with a [single pixel-wide set of lines](https://scikit-image.org/docs/0.25.x/auto_examples/applications/plot_morphology.html#skeletonize):

```{python}
# Skeletonize the xenomorph (skeletonomorph?)
skeletonized_xenomorph = ski.morphology.skeletonize(xenomorph)
plt.imshow(skeletonized_xenomorph);
```

We can also do this with less nightmarish results, to other images, such as the
much more friendly `horse` from `ski.data`:

```{python}
# Import the `horse` image from `ski.data`
horse = ski.data.horse()
plt.imshow(horse);
```

```{python}
show_attributes(horse)
```

```{python}
# Skeletonize `horse`.
skeleton_horse = ski.morphology.skeletonize(horse == 0) # The image must be binary numeric, not Boolean, to `skeletonize`.

plt.imshow(skeleton_horse);
```

Ok, maybe that is still quite nightmarish...


## Summary

On this page we have looked at fundamental morphological operations in
`skimage`, and particularly *erosion* and *dilation*.


## References

Based on:

* [Scientific Python Lectures on morphological
  operations](https://scikit-image.org/skimage-tutorials/lectures/3_morphological_operations.html)
* [This Napari-based
  tutorial](https://biapol.github.io/Image-data-science-with-Python-and-Napari-EPFL2022/day2d_image_segmentation/03_Morphological_operations.html).
