# More filters: the median filter

This page will cover another local filer - the median filter. The median filter differs in important ways from the local filters we saw on [previous](5_mean_filter) pages, because it cannot be implemented through convolution.

As normal, we begin with some imports:

```{python}
# Library imports.
import numpy as np
import matplotlib.pyplot as plt
import scipy.ndimage as ndi
import skimage as ski
from mpl_toolkits.mplot3d import Axes3D

# Set 'gray' as the default colormap
plt.rcParams['image.cmap'] = 'gray'

# Set NumPy precision to 2 decimal places
np.set_printoptions(precision=2)

#  A custom function to quickly report image attributes.
from show_attributes import show_attributes
```

# Median filter

When comparing to the other local filters we have seen, the median filter uses the same process of "walking" through the image with a small array which denfines the "local neighbourhood" of each pixel. In median filtering, you can *loosely* think of this small array as a kernel, but there are some major differences in the calculations, so let's call it the "neighbourhood array" instead. 

Like with the other kernels we have seen, the "neighbourhood array" is centered on every pixel during the filtering operation. The central pixel value is replaced with a number computed from the other values in the local neighbourhood, e.g. the other pixel values under the "neighbourhood array".  However, instead of *convolving* the neighbourhood array and the image, as we would for a mean filter or Gaussian filter etc., the median filter, shockingly, takes the median value of the pixels under the small array. 

![](images/kernel_general.png)

There is no convolvable function to calculate the median, and this is why [some people](https://dsp.stackexchange.com/questions/13211/convolution-kernels-for-image-filtering) will tell you not to call the "neighbourhood array" a "kernel", when we are doing median filtering. Calculating the median utilizes ranking and indexing, and cannot be expressed as set of additions, subtractions, mulitiplications, divisions etc, in the way that calculating a mean can, for instance.

One way to think of this, is that when we write the formula for the mean, we can write it without reference to any Python indexing operations:

$ \large \text{mean} = \frac{\sum X}{n} $

...we can read that as "to get the mean of a set of numbers (where $X$ refers all of the numbers), add them up and divide by however many numbers there are ($n$)". 

Conversely for the median we first have to order the numbers from lowest to highest ($X_{\text{sorted}}$), and then find the value that is *at the central index*. So where $X$ is an array containing all the numbers, if $n$ is odd:

$ \large \text{median} = X_{\text{sorted}}[\frac{n}{2}]$

Where the square brackets are a *Python* indexing operation (we will need a different indexing operation if using a programming language that does not count indexes from 0, or if $n$ is even...). So for the numbers in the array below:

```{python}
# Some numbers.
nums = np.array([10, 4, 5, 8, 7])

nums
```

We get the mean from: $ \large \text{mean} = \frac{\sum x_i...x_n}{n} $

```{python}
# Take the sum, divide by n.
np.sum(nums)/len(nums)
```

```{python}
# Compare to the same calculation from NumPy.
nums.mean()
```

Whereas we get the median from: $ \large \text{median} = X_{\text{sorted}}[\frac{n}{2}]$

```{python}
# Get the median.
sorted_nums = np.sort(nums) # Sort the values, low to high.
print(f"Sorted `nums`: {sorted_nums}")
median = sorted_nums[int(len(sorted_nums)/2)] # Index to get the median.

# Show the median value.
median
```

```{python}
# Compare to NumPy.
np.median(nums)
```

There is no convolution kernel that can do this - instead we use the "neighbourhood array" to define a pixel neighbourhood, then replace the central value with the median from that neighbourhood, using the sorting and indexing we have seen above. So, the median filter *is* a local filter, because it alters pixel values based on other pixel values in the local neighbourhood. However, it is not a *convolution filter* because it does use the local neighbourhood in a convolution operation, in contrast to other local filters like the mean filter, Gaussian filter etc. 

The median filter is especially useful for removing noise from images, while preserving the "edges" in the image. You'll recall that the edges are big changes in the gradient of pixel intensities, between nearby pixels (e.g. black-to-white, white-to-black etc). Let's look at why the median filter is "edge preserving", by expanding the `nums` array into a low-resolution image, using `np.tile()` and `.reshape()`.

```{python}
# Make `nums` into a image array.
nums_img = np.tile(nums, reps=3).reshape((3, 5))
nums_img 
```

```{python}
# Show as an image.
plt.matshow(nums_img);
```

Now, imagine we "walk" a 3-by-3 kernel (sorry, pedants!) through the `nums_img` array, and replace the central pixel of each kernel (sorry again, pedants!) with the median of the pixels under the kernel.

This process is shown below, for three kernels (OK, pedants, three "local neighbourhoods under a 3-by-3 array very much resembling a kernel"). The central pixel is highlighted in red, and the index of the current local neighbourhood is shown above the pixel values.

The flattened and sorted values from each local neighbourhood are also shown, along with the median value of the neighbourhood:

![](images/median_filter.png)


We can also show this in "Python space", using a for loop:

```{python}
# Show some local neighbourhoods of `nums_img` and their medians.
for i in np.arange(3):
    i_row_start, i_col_start = 0, i
    i_row_end, i_col_end = 3, i+3
    print(f"\nnums_img[{i_row_start}:{i_row_end}, {i_col_start}:{i_col_end}]")
    current_selection = nums_img[i_row_start:i_row_end, i_col_start:i_col_end]
    print(current_selection)
    print(f"Flattened and sorted: {np.sort(current_selection.ravel())}")
    print(f"Median = {np.median(nums_img[i_row_start:i_row_end, i_col_start:i_col_end])}")
```

Because the median is not a function which can be applied via convolution, we cannot apply it using `ndi.correlate()`, as we did with the other [local filters](5_mean_filter). 

We can apply it in `skimage` using `ski.filters.median()`. Again,  we supply a `footprint` argument to determine the size of each pixel's "local neighbourhood":

```{python}
# Median filter `nums_img`.
nums_median_filtered = ski.filters.median(nums_img, 
                                          footprint=np.ones((3,3)))
nums_median_filtered
```

Compare to the original `nums_img` array below:

```{python}
nums_img
```

The effect of the "edges" of the image is easier to see graphically:

```{python}
# Show the images.
plt.subplot(1, 2, 1)
plt.imshow(nums_img)
plt.title('Original')
plt.subplot(1, 2, 2)
plt.imshow(nums_median_filtered)
plt.title('Median Filtered');
```

Edges involving a bigger gradient have been preserved, whilst less prominent edges have been merged into more prominent ones.

In a higher resolution image, this can have the effect of removing noise whilst preserving edges.

We will demonstrate the median filter again with the `brick` image from `ski.data`:

```{python}
# Load in the `brick` image.
brick = ski.data.brick()
show_attributes(brick)
plt.imshow(brick);
```

We will also filter `brick` using a mean filter, with the same size kernel as the median filter:

```{python}
# Apply a median filter.
median_filtered_brick = ski.filters.median(brick, 
                                           footprint=np.ones((9,9)))

mean_filtered_brick = ski.filters.rank.mean(brick, 
                                            footprint=np.ones((9,9)))
# Plot both image to compare
plt.figure(figsize=(14, 4))
plt.subplot(1, 3, 1)
plt.title('Original Image')
plt.imshow(brick)
plt.subplot(1, 3, 2)
plt.title('Median Filtered')
plt.imshow(median_filtered_brick)
plt.subplot(1, 3, 3)
plt.title('Mean Filtered')
plt.imshow(mean_filtered_brick);
```

You can see that the edges in the images (transitions between pixels of very different intensities - in this case between the dark bricks and the lighter mortar lines) are less smoothed by the median filter than by the mean filter. This is considered a desirable property of the median filter.


# Summary

This page has showed how the median filter differs from other local filters which use convolution, as well as showed how to implement it using `skimage`.


# References

3.3.5 onward from: https://lectures.scientific-python.org/packages/scikit-image/index.html

Based on: https://scikit-image.org/skimage-tutorials/lectures/1_image_filters.html

Reference: https://jni.github.io/i2k-skimage-napari/lectures/1_image_filters.html
