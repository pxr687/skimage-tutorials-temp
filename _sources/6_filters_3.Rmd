# Image filtering III

```{python}
# Library imports.
import numpy as np
import matplotlib.pyplot as plt
import scipy.ndimage as ndi
import skimage as ski
from mpl_toolkits.mplot3d import Axes3D

# Set 'gray' as the default colormap
plt.rcParams['image.cmap'] = 'gray'

# Set NumPy precision to 2 decimal places
np.set_printoptions(precision=2)

#  A custom function to quickly report image attributes.
from show_attributes import show_attributes
```

# Median filter

### Add here: show median within a few kernels - but also mention it cannot be done via convolution

The median filter uses the same process of "walking" through the image with a kernel. However, instead of taking the mean of the kernel, takes the median value. The median filter is especially useful for removing noise from images, while preserving the "edges" in the image. We will demonstrate this with the `brick` image from `ski.data`:

```{python}
# Load in the `brick` image.
brick = ski.data.brick()
show_attributes(brick)
plt.imshow(brick);
```

We can easily implement a median filter using `ski.filters.median()`, again we supply a `footprint` argument to determine the kernel. We will also filter `brick` using a mean filter, with the same size kernel as the median filter:

```{python}
# Apply a median filter.
median_filtered_brick = ski.filters.median(brick, 
                                           footprint=np.ones((9,9)))

mean_filtered_brick = ski.filters.rank.mean(brick, 
                                            footprint=np.ones((9,9)))
# Plot both image to compare
plt.figure(figsize=(14, 4))
plt.subplot(1, 3, 1)
plt.title('Original Image')
plt.imshow(brick)
plt.subplot(1, 3, 2)
plt.title('Median Filtered')
plt.imshow(median_filtered_brick)
plt.subplot(1, 3, 3)
plt.title('Mean Filtered')
plt.imshow(mean_filtered_brick);
```

You can see that the edges in the images (transitions between pixels of very different intensities - in this case between the dark bricks and the lighter mortar lines) are less smoothed by the median filter than by the mean filter. This is considered a desirable property of the median filter.


# Sobel and Roberts filters

The Sobel and Roberts filters are other edge detection algorithms that also combine horizontal and vertical edge detection filters.

```{python}
# adapted from skimage docs
edge_roberts = ski.filters.roberts(edgy)
edge_sobel = ski.filters.sobel(edgy)

camera = ski.data.camera()
camera_roberts = ski.filters.roberts(camera)
camera_sobel = ski.filters.sobel(camera)

plt.figure(figsize=(12, 12))
plt.subplot(2, 2, 1)
plt.imshow(edge_roberts)
plt.title('Roberts Edge Detection')
plt.subplot(2, 2, 2)
plt.imshow(edge_sobel)
plt.title('Sobel Edge Detection')
plt.subplot(2, 2, 3)
plt.imshow(camera_roberts)
plt.title('Roberts Edge Detection')
plt.subplot(2, 2, 4)
plt.imshow(camera_sobel)
plt.title('Sobel Edge Detection')
plt.axis('off');
```

# Non-local filters

```{python}
camera_equalized = ski.exposure.equalize_hist(camera)

plt.figure(figsize=(10, 10))
plt.subplot(1, 2, 1)
plt.imshow(camera)
plt.subplot(1, 2, 2)
plt.imshow(camera_equalized);
```

# Summary

This page has showed how to use convolution kernels to filter images, using `numpy`, `scipy` and `skimage`.


# References

3.3.5 onward from: https://lectures.scientific-python.org/packages/scikit-image/index.html

Based on: https://scikit-image.org/skimage-tutorials/lectures/1_image_filters.html

Reference: https://www.kdnuggets.com/numpy-for-image-processing

Reference: https://setosa.io/ev/image-kernels

Reference: https://wiki.imindlabs.com.au/ds/aml/4_problem_domains/1-image-processing/3_edge_detectors

Reference: https://www.geeksforgeeks.org/deep-learning/types-of-convolution-kernels

Reference: skimage tutorials (check versions), scipy lecture notes

Reference: https://jni.github.io/i2k-skimage-napari/lectures/1_image_filters.html
