---
jupyter:
  orphan: true
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Image segmentation

This page based on [the Skimage segmentation
tutoria](https://scikit-image.org/skimage-tutorials/lectures/4_segmentation.html)

We do image segmentation when we classify the image into parts (segments).

One very common use of segmentation is to identify objects or parts of objects
in images.  For example, we might use segmentation to detect faces or people
within a larger image.

There are various ways to do this, many of them implemented in Scikit-image.


## Thresholding

If the image has two components to it, and these components have different intensity values, it may be useful to use a simple intensity threshold method, such as the [Otsu method](otsu-method), that we have already seen.

```{python}
import numpy as np
import scipy as sp
import matplotlib.pyplot as plt

import skimage as ski
```

Get the familiar cameraman image:

```{python}
camera = ski.data.camera()
plt.imshow(camera)
```

A simple threshold, such at the Otsu, may be able to identify parts of the image that contain objects of interest.

```{python}
val = ski.filters.threshold_otsu(camera)
hist, bins_center = ski.exposure.histogram(camera)

plt.figure(figsize=(9, 4))
plt.subplot(131)
plt.imshow(camera, cmap="gray", interpolation="nearest")
plt.axis("off")
plt.subplot(132)
plt.imshow(camera < val, cmap="gray", interpolation="nearest")
plt.axis("off")
plt.subplot(133)
plt.plot(bins_center, hist, lw=2)
plt.axvline(val, color="k", ls="--")

plt.tight_layout()
```

## Labelling connected components

Another approach is to identify connected components.

```{python}
n = 12
l = 256
rng = np.random.default_rng(27446968)
im = np.zeros((l, l))
points = l * rng.random((2, n**2))
im[(points[0]).astype(int), (points[1]).astype(int)] = 1
im = ski.filters.gaussian(im, sigma=l / (4.0 * n))
blobs = im > 0.7 * im.mean()

all_labels = ski.measure.label(blobs)
blobs_labels = ski.measure.label(blobs, background=0)

plt.figure(figsize=(9, 3.5))
plt.subplot(131)
plt.imshow(blobs, cmap="gray")
plt.axis("off")
plt.subplot(132)
plt.imshow(all_labels, cmap="nipy_spectral")
plt.axis("off")
plt.subplot(133)
plt.imshow(blobs_labels, cmap="nipy_spectral")
plt.axis("off")

plt.tight_layout()
plt.show()
```

## Marker based methods

## Watershed and random walker segmentation

```{python}
# Generate an initial image with two overlapping circles
x, y = np.indices((80, 80))
x1, y1, x2, y2 = 28, 28, 44, 52
r1, r2 = 16, 20
mask_circle1 = (x - x1) ** 2 + (y - y1) ** 2 < r1**2
mask_circle2 = (x - x2) ** 2 + (y - y2) ** 2 < r2**2
image = np.logical_or(mask_circle1, mask_circle2)

# Now we want to separate the two objects in image
# Generate the markers as local maxima of the distance
# to the background
distance = sp.ndimage.distance_transform_edt(image)
peak_idx = ski.feature.peak_local_max(
    distance, footprint=np.ones((3, 3)), labels=image)
peak_mask = np.zeros_like(distance, dtype=bool)
peak_mask[tuple(peak_idx.T)] = True
markers = ski.measure.label(peak_mask)
labels_ws = ski.segmentation.watershed(-distance, markers, mask=image)

markers[~image] = -1
labels_rw = ski.segmentation.random_walker(image, markers)

plt.figure(figsize=(12, 3.5))
plt.subplot(141)
plt.imshow(image, cmap="gray", interpolation="nearest")
plt.axis("off")
plt.title("image")
plt.subplot(142)
plt.imshow(-distance, interpolation="nearest")
plt.axis("off")
plt.title("distance map")
plt.subplot(143)
plt.imshow(labels_ws, cmap="nipy_spectral", interpolation="nearest")
plt.axis("off")
plt.title("watershed segmentation")
plt.subplot(144)
plt.imshow(labels_rw, cmap="nipy_spectral", interpolation="nearest")
plt.axis("off")
plt.title("random walker segmentation")

plt.tight_layout()
```
